// Built-in unique Symbols
// These don't have any special meaning on the Rust side, but are used in Minsc code for various purposes
null = symbol("null");
default = symbol("default");

// Common type checks
fn isArray($x) = typeof($x) == "array";
fn isFunction($x) = typeof($x) == "function";

//
// Array utilities
//
// len(), fillArray(), fold() & foldUntil() are Rust-provided builtins, everything else is built on top of them.

fn last($arr) = $arr.(len($arr) - 1);
fn range($start, $end) = fillArray(($end-$start)+1, |$n| $start+$n);
fn indices($arr) = range(0, len($arr) - 1);
fn slice($arr, $start, $len=(len($arr)-$start)) = fillArray($len, |$n| $arr.($start+$n));
fn tail($arr) = slice($arr, 1); // get all but first element
fn initial($arr) = slice($arr, 0, len($arr) - 1); // get all but last element
fn enumerated($arr) = fillArray(len($arr), |$i| [ $i, $arr.$i ]);
fn isEmpty($arr) = len($arr) == 0;

fn map($arr, $fn) = fillArray(len($arr), |$i| $fn($arr.$i));
fn filter($arr, $fn)  = fold($arr, [], |$acc, $el| $acc + (if $fn($el) then [ $el ] else [ ]));
fn flatMap($arr, $fn) = fold($arr, [], |$acc, $el| $acc + $fn($el));
fn each($arr, $fn) = fold($arr, null, |_, $el| { $fn($el); null });

fn reduce($arr, $fn) = if !isEmpty($arr) then fold(tail($arr), $arr.0, $fn) else null;

fn filterMap($arr, $fn) = flatMap($arr, |$el| { $r = $fn($el); if $r != filterMap::skip then [$r] else [] });
filterMap::skip = symbol("filterMap::skip");

fn find($arr, $fn) = foldUntil($arr, null,  |$acc, $el| if $fn($el) then true:$el  else false:null);
fn some($arr, $fn) = foldUntil($arr, false, |$acc, $el| if $fn($el) then true:true else false:false);
fn every($arr, $fn) = !some($arr, |$el| !$fn($el));

fn contains($arr, $needle) = some($arr, |$el| $el == $needle);
fn reverse($arr) = fillArray(len($arr), |$i| $arr.(len($arr)-$i-1));
fn startsWith($arr, $prefix) = (len($arr) >= len($prefix)) && every(indices($prefix), |$i| $arr.$i == $prefix.$i);

fn concat($xs) = reduce($xs, |$acc, $x| $acc + $x); // works for arrays, bytes, strings and numbers
fn flatten($arrays) = if !isEmpty($arrays) then concat($arrays) else [];

//
// Tagged Array utilities
//

fn get($tagged, $tag, $default_val=null) = if $tagged->{$tag}? then $tagged->{$tag} else $default_val;
fn mget($tagged, $tag) = $tagged | filter(|[$k, _]| $k == $tag) | map(|[_, $v]| $v);

fn keys($tagged) = map($tagged, |[$k, _]| $k);
fn values($tagged) = map($tagged, |[_, $v]| $v);

fn set($tagged, $fields) {
  filter($fields, |[_, $v]| $v != set::UNSET)
  + unset($tagged, keys($fields))
}
set::UNSET = symbol("set::UNSET");

fn unset($tagged, $keys) = filter($tagged, |[$k, _]| !contains($keys, $k));

// previous names for backwards compatibility, to be deprecated
update = set, remove = unset;

// Numeric
_ZEROS = [ "int": 0, "float": 0.0 ];
fn abs($n) = if $n < _ZEROS->{typeof($n)} then -$n else $n;
fn max($nums) = reduce($nums, |$a, $b| if $a>$b then $a else $b);
fn min($nums) = reduce($nums, |$a, $b| if $a<$b then $a else $b);
fn sum($ints) = concat([0]+$ints);
fn fsum($floats) = concat([0.0]+$floats);

// Null handling utilities
fn mapNullable($value, $fn, $default=null) = if $value != null then $fn($value) else $default;
fn coalesce($values) = find($values, |$v| $v != null);

// String utilities
fn join($strs, $sep="") =
  if isEmpty($strs) then ""
  else if len($strs) == 1 then str($strs.0)
  else if $sep == "" then concat([""] + $strs) // optimization for "" separator
  else concat([ str($strs.0) ] + map(tail($strs), |$str| $sep + $str));

// Rand utilities
// TODO `seed` parameter support
fn rand::u32() = abs(rand::i64() % (2**32));
fn rand::i32() = rand::u32() - (2**31);
fn rand::range($min, $max) = $min + abs(rand::i64() % ($max-$min+1)); // [$min, $max]
fn rand::frange($min, $max) = $min + (rand::f64() * ($max-$min)); // [$min, $max)


//
// Dev utilities
//

// Assertion
fn assert($bool, $msg="Assertion failed") = $bool || throw($msg);
fn assert::eq($a, $b) = ($a == $b) || throw("Not equal: "+$a+" != "+$b+"");

// Scope inspection
dyn fn env::pretty($$depth=(-1)) = _env($$depth) | map(|[$k:$v]| $k+" = "+pretty($v)+" // "+typeof($v)) | join("\n\n") | symbol();
dyn fn env::repr($$depth=(-1)) = _env($$depth) | filter(|[$k:$v]| !isFunction($v)) | map(|[$k:$v]| $k+" = "+repr($v)+"; // "+typeof($v)) | join("\n\n") | symbol();
dyn fn env::debug($$depth=(-1)) = _env($$depth) | map(|[$k:$v]| $k+" = "+_debug_nonfn($v)) | join("\n\n") | symbol();
dyn fn _env($$depth) = env(if $$depth <= 0 then $$depth else $$depth+2) | tail();
fn _debug_nonfn($v) = if !isFunction($v) then debug($v) else $v;

dyn fn log::env($label="") = log("variables:\n----\n" + env::pretty() + "\n----");
dyn fn log::debug_env($label="") = log("variables:\n----\n" + env::debug() + "\n----");

// Testing
T = [];
dyn fn test($topic, $test) {
  T = T + [ $topic ];
  $indent = if len(T) > 1 then join(fillArray(len(T)-1, "··"), "")+" " else "";
  print("[TEST] " + $indent + join(T, " · "));
  t::assert(if isFunction($test) then $test(T) else $test);
}
dyn fn t::assert($bool) = $bool || throw("["+last(T)+"] Assertion failed");
dyn fn t::eq($a, $b) = ($a == $b) || throw("["+last(T)+"] Not equal: "+$a+" != "+$b);
it = test;

BOO=symbol(
"           .     .
          (>\\---/<)
          ,'     `.
         /  q   p  \\
        (  >(_Y_)<  )
         >-' `-' `-<-.
        /  _.== ,=.,- \\
       /,    )`  '(    )
      ; `._.'      `--<
     :     \\        |  )
     \\      )       ;_/
      `._ _/_  ___.'-\\\\\\
         `--\\\\\\
 Boo, The Miniature Giant Space Hamster");