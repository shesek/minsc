// Built-in unique Symbols
// These don't have any special meaning on the Rust side, but are used in Minsc code for various purposes
null = symbol("null");
default = symbol("default");

// Common type checks
fn isArray($x) = typeof($x) == "array";
fn isFunction($x) = typeof($x) == "function";

//
// Array utilities
//
// len(), fillArray(), fold() & foldUntil() are Rust-provided builtins, everything else is built on top of them.

fn first($arr) = $arr.0;
fn last($arr) = $arr.(len($arr) - 1);
fn range($start, $end) = fillArray(($end-$start)+1, |$n| $start+$n);
fn keys($arr) = range(0, len($arr) - 1);
fn slice($arr, $start, $len) = fillArray($len, |$n| $arr.($start+$n));
fn tail($arr) = slice($arr, 1, len($arr) - 1); // get all but first element
fn initial($arr) = slice($arr, 0, len($arr) - 1); // get all but last element
fn isEmpty($arr) = len($arr) == 0;

fn map($arr, $fn)     = fold($arr, [], |$acc, $el| $acc + [ $fn($el) ]);
fn filter($arr, $fn)  = fold($arr, [], |$acc, $el| $acc + (if $fn($el) then [ $el ] else [ ]));
fn flatMap($arr, $fn) = fold($arr, [], |$acc, $el| $acc + $fn($el));

fn reduce($arr, $fn) = if !isEmpty($arr) then fold(tail($arr), $arr.0, $fn) else null;

fn filterMap($arr, $fn) = flatMap($arr, |$el| { $r = $fn($el); if $r != filterMap::skip then [$r] else [] });
filterMap::skip = symbol("filterMap::skip");

fn find($arr, $fn) = foldUntil($arr, null,  |$acc, $el| if $fn($el) then true:$el  else false:null);
fn some($arr, $fn) = foldUntil($arr, false, |$acc, $el| if $fn($el) then true:true else false:false);
fn every($arr, $fn) = !some($arr, |$el| !$fn($el));

fn contains($arr, $needle) = some($arr, |$el| $el == $needle);
fn reverse($arr) = map(keys($arr), |$i| $arr.(len($arr)-$i-1));
fn startsWith($arr, $prefix) = (len($arr) >= len($prefix)) && every(keys($prefix), |$i| $arr.$i == $prefix.$i);

fn concat($xs) = reduce($xs, |$acc, $x| $acc + $x); // works for arrays, bytes, strings and numbers
fn sum($nums) = if !isEmpty($nums) then concat($nums) else 0;
fn flatten($arrays) = if !isEmpty($arrays) then concat($arrays) else [];

// Null handling utilities
fn mapNullable($value, $fn) = if $value != null then $fn($value) else null;
fn coalesce($values) = find($values, |$v| $v != null);

// Immutably update the given fields, returning a new updated array
fn update($original, $updated_fields) {
  $updated_keys = map($updated_fields, |[$k, _]| $k);
  $updated_fields + remove($original, $updated_keys)
}
fn remove($original, $keys) = filter($original, |[$k, _]| !contains($keys, $k));

// String utilities
fn join($strs, $sep) =
  if isEmpty($strs) then ""
  else if len($strs) == 1 then $strs.0
  else concat([ $strs.0 ] + map(tail($strs), |$str| $sep + $str));

// Array tag extraction with multiple values (`$tagged->tag` can be used for a single value)
fn t::multi($tagged, $tag) = $tagged | filter(|[$k, _]| $k == $tag) | map(|[_, $v]| $v);

//
// Dev utilities
//

// Assertion
fn assert($bool, $msg="Assertion failed") = $bool || throw($msg);
fn assert::eq($a, $b) = ($a == $b) || throw("Not equal: "+$a+" != "+$b+"");

// Scope inspection
dyn fn env::pretty() = env() | map(|[$k:$v]| $k+" = "+pretty($v)+" // "+typeof($v)) | join("\n\n") | symbol();
dyn fn env::repr() = env() | filter(|[$k:$v]| !isFunction($v)) | map(|[$k:$v]| $k+" = "+repr($v)+"; // "+typeof($v)) | join("\n\n") | symbol();
dyn fn env::debug() = env() | map(|[$k:$v]| $k+" = "+_debug_nonfn($v)) | join("\n\n") | symbol();
fn _debug_nonfn($v) = if !isFunction($v) then debug($v) else $v;

dyn fn log::env($label="") = log("variables:\n----\n" + env::pretty() + "\n----");
dyn fn log::debug_env($label="") = log("variables:\n----\n" + env::debug() + "\n----");

// Testing
T = [];
dyn fn test($topic, $test) {
  T = T + [ $topic ];
  $indent = if len(T) > 1 then join(fillArray(len(T)-1, "··"), "")+" " else "";
  print("[TEST] " + $indent + join(T, " · "));
  t::assert(if isFunction($test) then $test(T) else $test);
}
dyn fn t::assert($bool) = $bool || throw("["+last(T)+"] Assertion failed");
dyn fn t::eq($a, $b) = ($a == $b) || throw("["+last(T)+"] Not equal: "+$a+" != "+$b);
it = test;
